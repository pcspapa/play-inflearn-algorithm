# 검색트리 - 이진검색트리 

## 트리의 기본 성질
* 노드가 N개인 트리는 항상 N-1개의 링크(link)를 가진다.
* 트리에서 루트에서 어떤 노드로 가는 경로는 유일하다. 또한 임의의 두 노드간의 경로도 유일하다.


## 이진 트리
* 이진 트리에서 각 노드는 최대 2개의 자식을 갖는다.
* 각각의 자식 노드는 자신이 부모의 왼쪽 자식인지 오른쪽 자식인지가 지정된다.



## 이진 검색 트리(Binary Search Tree) 1, 21:00, 23:49
* 이진 트리이면서
* 각 노드에 하나의 키를 저장
* 각 노드 v에 대해서 그 노드의 왼쪽 부트리(subtree)에 있는 키들은 key[v]보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같다. 

### Dynamic set
* INSERT, SEARCH, DELETE

### 다양한 방법
* 정렬된 혹은 정렬되지 않은 배열 혹은 연결 리스트를 사용할 경우 
  - INSERT, SEARCH, DELETE 중 적어도 하나는 O(n)
* 이진탐색트리, 레드-블랙 트리, AVL-트리등의 트리에 기반한 구조들
* Direct Address Table, 해쉬 테이블 등
  
## 이진 검색 트리(Binary Search Tree) 2, 12:33, 21:46

### Minimum Search

### Maximum Search

### Successor - Search
> 나보다 크면서 가장 작은 값.
* 3가지 경우
  * 노드 x의 오른쪽 부트리가 존재할 경우, 오른쪽 부트리의 최소값
  * 오른쪽 부트링가 없는 경우, 어떤 노드 y의 왼쪽 부트리의 최대값이 x가 되는 그런 노드 y가 x의 successor
    * 부모를 따라 루트까지 올라가면서 처음으로 누군가의 왼쪽 자식이 되는 노드
  * 그런 노드 y가 존재하지 않을 경우 successor가 존재하지 않음(즉, x가 최대값)
  
### Presuccessor - Search
> 나보다 작으면서 가장 큰 값.

### Insert

## 이진 검색 트리(Binary Search Tree) 3, 14:28

### Delete
* CASE 1: 자식노드가 없는 경우
* CASE 2: 자식노드가 1개인 경우
* CASE 3: 자식노드가 2개인 경우

### Binary Search Tree
* 각종 연산의 시간복잡도
* 그러나, 최악의 경우 트리의 높이 h=O(n)
* 규형잡힌(balanced) 트리
  * 레드-블랙 트리 등
  * 키의 삽입이나 삭제 시 추가로 트리의 균형을 잡아줌으로써 높이를 O(log2n)으로 유지 